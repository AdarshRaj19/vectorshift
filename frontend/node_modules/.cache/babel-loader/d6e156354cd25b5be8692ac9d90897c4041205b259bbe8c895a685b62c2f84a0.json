{"ast":null,"code":"// store.js\n\nimport { create } from \"zustand\";\nimport { addEdge, applyNodeChanges, applyEdgeChanges, MarkerType } from 'reactflow';\nconst saveToHistory = (newState, currentState) => {\n  const history = [...currentState.history.slice(0, currentState.historyIndex + 1)];\n  history.push({\n    nodes: currentState.nodes,\n    edges: currentState.edges,\n    nodeIDs: currentState.nodeIDs\n  });\n  return {\n    ...newState,\n    history,\n    historyIndex: history.length - 1\n  };\n};\nexport const useStore = create((set, get) => ({\n  nodes: [],\n  edges: [],\n  nodeIDs: {},\n  history: [],\n  historyIndex: -1,\n  getNodeID: type => {\n    const newIDs = {\n      ...get().nodeIDs\n    };\n    if (newIDs[type] === undefined) {\n      newIDs[type] = 0;\n    }\n    newIDs[type] += 1;\n    set({\n      nodeIDs: newIDs\n    });\n    return `${type}-${newIDs[type]}`;\n  },\n  addNode: node => {\n    set(state => {\n      const newState = {\n        nodes: [...state.nodes, node],\n        edges: state.edges,\n        nodeIDs: state.nodeIDs\n      };\n      return saveToHistory(newState, state);\n    });\n  },\n  onNodesChange: changes => {\n    set(state => {\n      const newNodes = applyNodeChanges(changes, state.nodes);\n      const newState = {\n        ...state,\n        nodes: newNodes\n      };\n      return saveToHistory(newState, state);\n    });\n  },\n  onEdgesChange: changes => {\n    set(state => {\n      const newEdges = applyEdgeChanges(changes, state.edges);\n      const newState = {\n        ...state,\n        edges: newEdges\n      };\n      return saveToHistory(newState, state);\n    });\n  },\n  onConnect: connection => {\n    set(state => {\n      const newEdges = addEdge({\n        ...connection,\n        type: 'smoothstep',\n        animated: true,\n        markerEnd: {\n          type: MarkerType.Arrow,\n          height: '20px',\n          width: '20px'\n        }\n      }, state.edges);\n      const newState = {\n        ...state,\n        edges: newEdges\n      };\n      return saveToHistory(newState, state);\n    });\n  },\n  updateNodeField: (nodeId, fieldName, fieldValue) => {\n    set({\n      nodes: get().nodes.map(node => {\n        if (node.id === nodeId) {\n          node.data = {\n            ...node.data,\n            [fieldName]: fieldValue\n          };\n        }\n        return node;\n      })\n    });\n  },\n  savePipeline: () => {\n    const {\n      nodes,\n      edges\n    } = get();\n    localStorage.setItem('vectorshift-pipeline', JSON.stringify({\n      nodes,\n      edges\n    }));\n  },\n  loadPipeline: () => {\n    const saved = localStorage.getItem('vectorshift-pipeline');\n    if (saved) {\n      const {\n        nodes,\n        edges\n      } = JSON.parse(saved);\n      set({\n        nodes,\n        edges\n      });\n    }\n  },\n  clearPipeline: () => {\n    set({\n      nodes: [],\n      edges: [],\n      nodeIDs: {},\n      history: [],\n      historyIndex: -1\n    });\n  },\n  undo: () => {\n    set(state => {\n      if (state.historyIndex > 0) {\n        const prevState = state.history[state.historyIndex - 1];\n        return {\n          ...prevState,\n          history: state.history,\n          historyIndex: state.historyIndex - 1\n        };\n      }\n      return state;\n    });\n  },\n  redo: () => {\n    set(state => {\n      if (state.historyIndex < state.history.length - 1) {\n        const nextState = state.history[state.historyIndex + 1];\n        return {\n          ...nextState,\n          history: state.history,\n          historyIndex: state.historyIndex + 1\n        };\n      }\n      return state;\n    });\n  }\n}));","map":{"version":3,"names":["create","addEdge","applyNodeChanges","applyEdgeChanges","MarkerType","saveToHistory","newState","currentState","history","slice","historyIndex","push","nodes","edges","nodeIDs","length","useStore","set","get","getNodeID","type","newIDs","undefined","addNode","node","state","onNodesChange","changes","newNodes","onEdgesChange","newEdges","onConnect","connection","animated","markerEnd","Arrow","height","width","updateNodeField","nodeId","fieldName","fieldValue","map","id","data","savePipeline","localStorage","setItem","JSON","stringify","loadPipeline","saved","getItem","parse","clearPipeline","undo","prevState","redo","nextState"],"sources":["C:/Users/ADMIN/Desktop/New folder/vectorshift/frontend/src/store.js"],"sourcesContent":["// store.js\n\nimport { create } from \"zustand\";\nimport {\n    addEdge,\n    applyNodeChanges,\n    applyEdgeChanges,\n    MarkerType,\n  } from 'reactflow';\n\nconst saveToHistory = (newState, currentState) => {\n    const history = [...currentState.history.slice(0, currentState.historyIndex + 1)];\n    history.push({ nodes: currentState.nodes, edges: currentState.edges, nodeIDs: currentState.nodeIDs });\n    return {\n        ...newState,\n        history,\n        historyIndex: history.length - 1\n    };\n};\n\nexport const useStore = create((set, get) => ({\n    nodes: [],\n    edges: [],\n    nodeIDs: {},\n    history: [],\n    historyIndex: -1,\n    getNodeID: (type) => {\n        const newIDs = {...get().nodeIDs};\n        if (newIDs[type] === undefined) {\n            newIDs[type] = 0;\n        }\n        newIDs[type] += 1;\n        set({nodeIDs: newIDs});\n        return `${type}-${newIDs[type]}`;\n    },\n    addNode: (node) => {\n        set((state) => {\n            const newState = {\n                nodes: [...state.nodes, node],\n                edges: state.edges,\n                nodeIDs: state.nodeIDs\n            };\n            return saveToHistory(newState, state);\n        });\n    },\n    onNodesChange: (changes) => {\n        set((state) => {\n            const newNodes = applyNodeChanges(changes, state.nodes);\n            const newState = { ...state, nodes: newNodes };\n            return saveToHistory(newState, state);\n        });\n    },\n    onEdgesChange: (changes) => {\n        set((state) => {\n            const newEdges = applyEdgeChanges(changes, state.edges);\n            const newState = { ...state, edges: newEdges };\n            return saveToHistory(newState, state);\n        });\n    },\n    onConnect: (connection) => {\n        set((state) => {\n            const newEdges = addEdge({...connection, type: 'smoothstep', animated: true, markerEnd: {type: MarkerType.Arrow, height: '20px', width: '20px'}}, state.edges);\n            const newState = { ...state, edges: newEdges };\n            return saveToHistory(newState, state);\n        });\n    },\n    updateNodeField: (nodeId, fieldName, fieldValue) => {\n      set({\n        nodes: get().nodes.map((node) => {\n          if (node.id === nodeId) {\n            node.data = { ...node.data, [fieldName]: fieldValue };\n          }\n  \n          return node;\n        }),\n      });\n    },\n    savePipeline: () => {\n      const { nodes, edges } = get();\n      localStorage.setItem('vectorshift-pipeline', JSON.stringify({ nodes, edges }));\n    },\n    loadPipeline: () => {\n      const saved = localStorage.getItem('vectorshift-pipeline');\n      if (saved) {\n        const { nodes, edges } = JSON.parse(saved);\n        set({ nodes, edges });\n      }\n    },\n    clearPipeline: () => {\n      set({ nodes: [], edges: [], nodeIDs: {}, history: [], historyIndex: -1 });\n    },\n    undo: () => {\n        set((state) => {\n            if (state.historyIndex > 0) {\n                const prevState = state.history[state.historyIndex - 1];\n                return {\n                    ...prevState,\n                    history: state.history,\n                    historyIndex: state.historyIndex - 1\n                };\n            }\n            return state;\n        });\n    },\n    redo: () => {\n        set((state) => {\n            if (state.historyIndex < state.history.length - 1) {\n                const nextState = state.history[state.historyIndex + 1];\n                return {\n                    ...nextState,\n                    history: state.history,\n                    historyIndex: state.historyIndex + 1\n                };\n            }\n            return state;\n        });\n    },\n  }));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}